# -*- coding: utf-8 -*-
"""2023-1 HMCIA - Introduction to Python - 01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Bc-VnfZfEtL9tgjnhZCD_6dmJKAA9JW1

#Installing modules
"""

#!pip install mglearn

"""#Importing  Libraries"""

# importing modules
import numpy as np
import scipy as sp

"""# Printing or Data Output

To print data, we use the "print" function

The print function allows you to print data of type string, int and float.

It is possible to create data print statements efficiently by using the print format.


"""

print('Hello World')
print("Hello World")

"""#Indentation"""

x=1
if x==1:
  print("the condition is true")
print("but this is outside the condition")

"""#Naming Variables"""

variable=1
vari_able=1
variable_1=1
Variable=2
variable==Variable
#1Variable=1

"""# Key words

---
#Group task:
Find out why these words are forbidden as variable names, and what is their use in Python
---
---

#Comments
"""

#This is a comment

"""
This is a 
multiline
comment
"""

'''
This is another
multiline
comment
'''

x=1

"""#Assigning values to variables"""

a=1
b=2
c=3

a,b,c=1,2,3

d=None

print(a,b,c,d)

"""#Numbers"""

a=4
b=4.0
c=4+0j

print(a,b,c)

"""#Operators"""

a,b=2,3
print(a+b)
print(a-b)
print(a*b)
print(a/b)
print(a//b)
print(a%b)
print(a**b)


a+=b; print(a)
a-=b; print(a)
a*=b; print(a)
a/=b; print(a)
a//=b; print(a)
a%=b; print(a)
a**=b; print(a)

a,b=2,3
print(a&b)
print(a|b)
print(a^b)
print(a>>b)
print(a<<b)

a=True
b=False
print(a and b)
print(a or b)
print(not a)

a=4
b=3
print(a<b)
print(a>b)
print(a==b)
print(a!=b)
print(a>=b)
print(a<=b)

"""#Strings"""

a="This is a string"
b="This is another string"
print(b[0])
print(b[0:5])
print(b[-4:])
print(b[:6])
print(b[:-3])

print('Una de mis series favoritas es "Resident Evil".')
print("The Devil\'s own es una buena película")
print('La receta auténtica del alioli:\n- Ajo\n- Aceite')
print('Manzana\tPera\tCiruela\nMelón\tSandía\tFresa')
print('Hello "Python"')
print("Hello 'Python'")

print("""
Una de mis series favoritas era "Resident Evil"
The Devil\'s own es una buena película
Manzana  Pera  Ciruela
Melón  Sandía  Fresa""")

print(a+b)
print(a*3)
print(len(a))
print(a.find('string'))
print(b.find('string'))
a=a.upper()
print(a)
a=a.lower()
print(a)
b.replace('string','spaghetti')

"""#Type None
When we want to declare a variable but not define it's type, we can define it as "None"
"""

a=None
type(a)

"""#Type conversions"""

a=85
str(a)
type(str(a))
a=45.23
a=int(a);print(a)
a=float(a);print(a)
a=complex(a);print(a)
a=1;print(bool(a))
a=20;print(bool(a))
a=0;print(bool(a))
a=-10;print(bool(a))

"""### Lists
This is the most common data structure in Python


It is mutable:
This means we can change an item in a list by accessing it directly as part of the assignment statement. Using the indexing operator (square brackets) on the left side of an assignment, we can update one of the list items.

One list can contain different types of data (strings, integers, booleans, other lists)



"""

mylist = [4, 'Hi', True]; print(mylist)
mylist = []; print(mylist)
mylist = [4, 'Hi', True, False, 84,'Many',True]; 
print(mylist[2])
print(mylist[:3])
print(mylist[2:])
print(mylist[-2:])
print(len(mylist))
print(mylist.index(True)) 
''' be careful, this only finds the FIRST index 
where you can find the element "True"'''
mylist.insert(3,'New Insert');print(mylist)
mylist.append(['A List','Whithin a List']);print(mylist)
mylist.extend(['one more','two more']);print(mylist) 
'''this is different from append. a list is not inserted as a list withing 
a list but as individual elements within the old list'''
mylist.remove(84);print(mylist)
mylist.remove(True);print(mylist) #careful, this only removes the first True
mylist.extend(['repeatme','repeatme','repeatme','repeatme','repeatme']);print(mylist)
print(mylist.count('repeatme'))
mylist.reverse();print(mylist)
mylist[7:9].reverse();print(mylist) #this doesn't work, reverse only works on the full list
#mylist.sort();print(mylist) this doesn't work because elements have different types
mylist=[86, 42, 78, 95, 1, 102];print(mylist)
mylist.sort();print(mylist)
mylist.sort(reverse=True);print(mylist)
mylist=['B','A','C','H','X','M','D','T','Z','O'];print(mylist)
mylist.sort();print(mylist)
mylist.sort(reverse=True);print(mylist)
mylist.pop(); print(mylist); #removes and returns last element from the list
mylist.pop(3); print(mylist) #removes and returns third element from the list
w,x,y,z,a,b,c,d=mylist
print(w);print(x);print(y);print(z);print(a);print(b);print(c);print(d);
mylist[2]='changeme';print(mylist)

"""#Formatting printed variables

"""

# Python program showing how to use
# string modulo operator(%) to print
# fancier output
 
# print integer and float value
print("An integer number : %d" % (102))
 
# print integer and float value
print("A float number : %.2f" % (5.333))

# print octal value
print("%.3o" % (25))

# print binary value
print(bin(25))
 
# print exponential value
print("%.3E" % (356.08977))

"""# Lists
This is the most common data structure in Python

It is mutable:
This means we can change an item in a list by accessing it directly as part of the assignment statement. Using the indexing operator (square brackets) on the left side of an assignment, we can update one of the list items.

One list can contain different types of data (strings, integers, booleans, other lists)



"""

mylist = [4, 'Hi', True]; print(mylist)
mylist = []; print(mylist)
mylist = [4, 'Hi', True, False, 84,'Many',True]; 
print(mylist[2])
print(mylist[:3])
print(mylist[2:])
print(mylist[-2:])
print(len(mylist))
print(mylist.index(True)) 
''' be careful, this only finds the FIRST index 
where you can find the element "True"'''
mylist.insert(3,'New Insert');print(mylist)
mylist.append(['A List','Whithin a List']);print(mylist)
mylist.extend(['one more','two more']);print(mylist) 
'''this is different from append. a list is not inserted as a list withing 
a list but as individual elements within the old list'''
mylist.remove(84);print(mylist)
mylist.remove(True);print(mylist) #careful, this only removes the first True
mylist.extend(['repeatme','repeatme','repeatme','repeatme','repeatme']);print(mylist)
print(mylist.count('repeatme'))
mylist.reverse();print(mylist)
mylist[7:9].reverse();print(mylist) #this doesn't work, reverse only works on the full list
#mylist.sort();print(mylist) this doesn't work because elements have different types
mylist=[86, 42, 78, 95, 1, 102];print(mylist)
mylist.sort();print(mylist)
mylist.sort(reverse=True);print(mylist)
mylist=['B','A','C','H','X','M','D','T','Z','O'];print(mylist)
mylist.sort();print(mylist)
mylist.sort(reverse=True);print(mylist)
mylist.pop(); print(mylist); #removes and returns last element from the list
mylist.pop(3); print(mylist) #removes and returns third element from the list
w,x,y,z,a,b,c,d=mylist
print(w);print(x);print(y);print(z);print(a);print(b);print(c);print(d);
mylist[2]='changeme';print(mylist)

"""#Tuples
Items of any data type can be stored in them.

Items can be accessed by their index.

But they are DIFFERENT from lists!!!

The key difference between the tuples and lists is that while the tuples are immutable objects the lists are mutable. This means that tuples cannot be changed while the lists can be modified.

Tuples are more memory efficient than the lists.

When it comes to the time efficiency, again tuples have a slight advantage over the lists especially when lookup to a value is considered.
If you have data which is not meant to be changed in the first place, you should choose tuple data type over lists.
"""

mytuple = (); print(mytuple)
mytuple = (4, 'Hi', True, False, 'Hola', 54, 'Hola', 'Hola'); print(mytuple)
print(type(mytuple))
print(mytuple[2])
print(mytuple[:3])
print(mytuple[2:])
print(mytuple[-2:])
w,x,y,z,a,b,c,d=mytuple
print(w);print(x);print(y);print(z);print(a);print(b);
'''mytuple[2]='changeme';print(mytuple) #this is the key difference 
between list and tuple, you can't change individual elements in a tuple'''
print(mytuple.count('Hola'))
print(len(mytuple))
print(mytuple.index(True)) 
'''#be careful, this only finds the FIRST index where you can find the element 
"True" 
# you can't insert, append, extend, reverse, sort or remove'''
mytuple=(86, 42, 78, 95, 1, 102);print(mytuple)
#mytuple.sort();print(mytuple)

"""#Dictionaries
A dictionary is a collection which is ordered (after Python 3), changeable and do not allow duplicates
Dictionary items are presented in key:value pairs, and can be referred to by using the key name.

"""

thisdict = { "brand": "Ford",  "electric": False,  "year": 1964,  "colors": ["red", "white", "blue"]}
#keys could be numerical but that woulc create problems with functions such as "sorted"
print(thisdict['brand'])
thisdict['anotherkey']=1982
print(thisdict)
emptydict={}
print(emptydict)
emptydict=dict()
print(emptydict)
print(list(thisdict)) #list the keys of the dictionary (unsorted)
print(sorted(thisdict)) #list the keys of the dictionary (sorted)
print('electric' in thisdict) #check if a key is present in the dictionary
print('color' in thisdict)

"""# Sets

Sets are used to store multiple items in a single variable.

A set is a collection which is unordered, unchangeable, and unindexed.

Set items are unchangeable, but you can remove items and add new items.

Set items are unique
"""

emptyset = set() 
thisset = {"apple", "banana", "cherry"}
anotherset = {'audi', 'mercedes', 'seat', 'ferrari', 'ferrari', 'renault','banana'} 

print(emptyset)
print(thisset)
print(anotherset)
print(thisset.union(anotherset))
print(thisset.intersection(anotherset))
print(thisset.difference(anotherset))
print(anotherset.difference(thisset))
print('banana' in thisset)
print(len(thisset))
thisset.add("banana")
print(thisset)
thisset.add("lemmon")
print(thisset)

"""# If … elif … else Conditionals

The if ... else ... control structure allows a program to execute some statements when a condition is met and other statements when that condition is not met. The elif structure allows multiple conditions to be chained together.
"""

mynumbers = [3,8,7,14]
mynumbers.sort()
print(mynumbers)
a_number=9
if a_number in mynumbers:
    print(a_number, " is in ", mynumbers)
elif a_number >mynumbers[-1]:
    print(a_number, "is not in ", mynumbers, " and it is larger than the largest element of ", mynumbers)
elif a_number <mynumbers[0]:
    print(a_number, "is not in ", mynumbers, " and it is smaller than the smallest element of ", mynumbers)
else:
    print(a_number, "is not in ", mynumbers, " but it is within the range of the minimum and maximum elements of ", mynumbers)
#short if
if a_number in mynumbers: print(a_number, " is in ", mynumbers)
#short if else
print(a_number, " is in ", mynumbers) if a_number in mynumbers else print(a_number, " is not in ", mynumbers)

"""# While Loops

The While loop is a control structure that allows repeating the execution of a group of instructions while a condition is met.

**break**: esta sentencia rompe la ejecución del bucle en el momento en que se ejecute. 

**continue**: esta instrucción permite saltarnos una iteración del bucle sin que se rompa la ejecución final. 
"""

mynumbers = [1,2,3,8,4,7,14]
mynumbers.sort()
print(mynumbers)
k=0
while k<(len(mynumbers)):
  print(mynumbers[k])
  k+=1

print('\n')
k=0
while k<(len(mynumbers)):
  if mynumbers[k]==8:
    k+=1
    continue
  print(mynumbers[k])
  k+=1
print('\n')

k=0
while k<(len(mynumbers)):
  if mynumbers[k]==8:
    break
  print(mynumbers[k])
  k+=1

"""**While... Else**:
In this syntax, the condition is checked at the beginning of each iteration.
The code block inside the while statement will be executed as long as the condition is true.
When the condition returns false and the loop executes normally, the else clause will be executed.
However, if the loop is prematurely terminated by a break or return statement, the else clause will not be executed at all.


#Example While vs While else: 
We want to make a program that allows users to enter the name of a fr
uit. Based on the input name, we will look for it in the basket list and display its quantity if the fruit is listed. In case the fruit is not found, we will allow users to enter the amount of that fruit and add it to the list.
"""

#While 
basket=[
{'fruit':'apple','qty':20},
{'fruit':'banana','qty':30},
{'fruit':'orange','qty':10}
]
fruit=input('Enter a fruit:')
index=0
found_it=False
while index<len(basket):
  item=basket[index]
  #checkthefruitname
  if item['fruit']==fruit:
    found_it=True
    print(f"The basket has {item['qty']} {item['fruit']}(s)")
    break
  index+=1
if not found_it:
  qty=int(input(f'Enter the quantity for {fruit}:'))
  basket.append({'fruit':fruit,'qty':qty})
  print(basket)

#While Else

basket = [
    {'fruit': 'apple', 'qty': 20},
    {'fruit': 'banana', 'qty': 30},
    {'fruit': 'orange', 'qty': 10}
]
fruit = input('Enter a fruit:')
index = 0
while index < len(basket):
    item = basket[index]
    # check the fruit name
    if item['fruit'] == fruit:
        print(f"The basket has {item['qty']} {item['fruit']}(s)")
        found_it = True
        break
    index += 1
else:
    qty = int(input(f'Enter the qty for {fruit}:'))
    basket.append({'fruit': fruit, 'qty': qty})
    print(basket)

"""#For (Else) loop

It is a control structure that repeats a block of instructions a predetermined number of times. You can include an "else" that works the same as in the while-else. Remember that it is not mandatory (and many times it's unnecessary)
"""

for k in mynumbers:
  print(k)
else:
  print('the for loop finished')
mylist = [4, 'Hi', True, False, 84,'Many',True]; print(mylist); 
for k in mylist: print(k)

mytuple = (4, 'Hi', True, False, 'Hola', 54, 'Hola', 'Hola'); print(mytuple)
for k in mytuple: print(k)

mydict = { "brand": "Ford",  "electric": False,  "year": 1964,  "colors": ["red", "white", "blue"]}; print(mydict)
for k in mydict: print(k)

myset = {'audi', 'mercedes', 'seat', 'ferrari', 'ferrari', 'renault','banana'} ;print(myset)
for k in myset: print(k)


numeros = [5, 4, 3, 2, 1, 0] 
for numero in numeros: 
  print(numero) 
else: 
  print("Ya he acabado!") 

texto = 'Hola mundo' 
for caracter in texto: 
  print(caracter) 

lista = ['texto', 5, (23, 56)] 
for elemento in lista: 
   print(elemento) 


cadena = 'Hola mundo' 
# Comenzamos en 0, hasta la longitud de la cadena y con paso = 2 
for i in range(0, len(cadena), 2):   
  print(cadena[i])

"""#Functions
A function is a block of code which only runs when it is called.

You can pass data, known as parameters, into a function.

A function can return data as a result.

A parameter is the variable listed inside the parentheses in the function definition.

An argument is the value that is sent to the function when it is called.

You can pass arguments by position or by name
"""

def cilinder_volume(radius,height):
  import numpy as np #check this, we have imported numpy inside circle_area, but not outside
  volume=height*np.pi*radius**2
  return volume

#print(np.pi) #this doesn't work because numpy is not imported in this workspace
print(cilinder_volume(2,3)) #pass by position
print(cilinder_volume(height=3,radius=2)) #pass by name

def cilinder_volume(radius=2,height=3): #defined default values for both parameters
  import numpy as np #check this, we have imported numpy inside circle_area, but not outside
  volume=height*np.pi*radius**2
  return volume

print(cilinder_volume())

def cilinder_volume(height, radius=2): #defined default values for only one parameter
  import numpy as np #check this, we have imported numpy inside circle_area, but not outside
  volume=height*np.pi*radius**2
  return volume

print(cilinder_volume(3,2))
print(cilinder_volume(3))

"""# Functions with variable arguments
We use the “wildcard” or “*” notation like this – *args OR **kwargs – as our function’s argument when we have doubts about the number of  arguments we should pass in a function

The special syntax *args in function definitions in python is used to pass a variable number of arguments to a function. It is used to pass a non-key worded, variable-length argument list. 

The special syntax **kwargs in function definitions in python is used to pass a keyworded, variable-length argument list. We use the name kwargs with the double star. The reason is that the double star allows us to pass through keyword arguments (and any number of them).
"""

def myFun(*args):
    i=0
    printthis=[]
    for arg in args:
        printthis.append(arg)
    print(printthis)
myFun('Hello', 'it\'s me ', 'to', 'GeeksforGeeks')

def myFun(arg1, *args):
    print("First argument :", arg1)
    for arg in args:
        print("Next argument through *args :", arg)
myFun('Hello', 'Welcome', 'to', 'GeeksforGeeks')

def myFun(*args, **kwargs):
    print("args: ", args)
    print("kwargs: ", kwargs)
# Now we can use both *args ,**kwargs
# to pass arguments to this function :
myFun('geeks', 'for', 'geeks', first="Geeks", mid="for", last="Geeks")


def myFun(arg1, arg2, arg3):
    print("arg1:", arg1)
    print("arg2:", arg2)
    print("arg3:", arg3)

args = ("Geeks", "for", "Geeks")
myFun(*args)
 
kwargs = {"arg1": "Geeks", "arg2": "for", "arg3": "Geeks"}
myFun(**kwargs)

"""#Documenting functions

In order to document the functions, docstrings are used. In Python, all objects have a default variable called doc, and it allows us to access the documentation of said object. To document a function using docstrings, we just need to include a comment immediately after the function header.
By documenting functions in this way, we can use the help() statement with the function name to see what documentation it has. In the example above it would look like this:
"""

def potencia(base, exponente):
  """ 
  Función que calcula la potencia de dos números. 
  Argumentos: 
  base ‐‐ base de la operación. 
  exponente ‐‐ exponente de la operación. 
  """
  return base**exponente

help(potencia)

"""#Anonymous functions 
Anonymous functions are functions to which we will not assign an identifier to execute them. That is, we will not use the header def NOMBRE_FUNCION to define them. The purpose of these functions is the same as that of normal functions, with the exception that in these functions we cannot include a block of code, only a single expression. To implement anonymous functions in Python, we will use lambda expressions. These expressions are very powerful, although somewhat confusing, especially when they begin to be used.
"""

'''
One advantage of using this type of function is by combining it with the filter() or map() functions. 
The filter function allows us to filter elements of a sequence if they fulfill a conditional function. 
This function must receive two arguments, the first of which is a function, and the second is an object of type sequence. 
Let's look at an example where we look for the even numbers in a list.  
'''
# We define the list with the numbers that we are going to analyze.  
lista = [1,2,3,4,5,6,7,8,9,10] 
# We define the lambda expression that analyzes whether a number is even or not.  
es_par = lambda numero: numero % 2 == 0 

# We apply the filter to get the even numbers. We have to insert it into a list to have the result in ready format.  
list(filter(es_par, lista)) # Nos devolverá [2, 4, 6, 8, 10] 

'''
The map function allows us to apply a function to all the elements of a sequence. 
To do this, we pass as arguments of the map function, first, the function that we want to apply 
and, then, the object with the elements to which we want to apply the function. 
For example, let's apply the square function to the list above:
'''
cuadrado = lambda x: x ** 2 
list(map(cuadrado, lista)) # Nos devolverá [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

"""#List Comprehension 
List compression is a way provided by Python that allows us to create lists where each member of the list is the result of an operation. For example, let's say we want to create a list that stores the result of applying the square to the numbers 1 to 10. 

The structure of a list compression is:

[operation for item in sequence]
"""

#the "for" way
result = [] 
for i in range(1, 11): 
    result.append(i ** 2) 
print(result)

#the compression way
result = [i**2 for i in range(1,11)] 
print(result)

"""The use of list compression makes the code more compact and, above all, the execution much faster.

This structure can include conditional expressions that must be fulfilled so that an element can be included in the resulting list. The scheme of list compression with conditional expressions would be the following:

[operation for item in sequence if condition]

or 

[operation if condition else anotheroperation for x in sequence]
"""

result = [i**2 for i in range(1,11) if i % 3 == 0] 
print(result)

result = [i**2 if i % 3 == 0 else i for i in range(1,11) ] 
print(result)

"""For dictionaries, we need to define the key and value of each element that we insert into them. For this reason, the compression expression for dictionaries must include both concepts, the rest of the expression is the same as the previous one:

{key: value for item in sequence if condition}

 In the case of sets, we'll use the set creation symbols, followed by the same compression structure we used with lists:

{item for item in secuencia if condicion} 


"""

result = {i: i**2 for i in range(1,11) if i % 2 == 0} 
print(result)


result = {i**2 for i in range (1,11) if i % 2 == 0} 
print(result)

"""#Errors and Exceptions

Sometimes, we can assume that an error of a certain type may occur at some point and we do not want the execution of the program to be terminated.

In order to do this we will use exceptions. An exception is a block of code that will be executed when an error of some kind is detected, and after which we can continue executing our program. In order to do this, you need to use try blocks in conjunction with except blocks of code.
"""

lista = [2, 3, 4] 
 
for i in range (7):
  try: 
    print(lista[i]) 
  except: 
    print("No existe esa posición")

lista1=[*range(20)]
lista2 = [2, 3, 4, "A", 27, ""] 

for i in lista2:
  try: 
    print(lista1[i]) 
  except IndexError: 
    print("No existe esa posición") 
  except TypeError: 
    print("El tipo de la operación es erróneo") 
  except: 
    print("Ha ocurrido otro error") 
  else: 
    print("todo bien") 
  finally: 
    print("Hemos terminado el bloque try-except")

"""#Creating Classes

There are several programming paradigms (ways of structuring the code, variables and functions in order to perform given activities).
The two most common paradigms are Procedural Programming and Object-Oriented Programming (OOP).

Classes are characteristic of OOP, and serve as templates for objects that share similar properties. These objects have internal attributes and methods. This way of programming provides an encapsulation that can be better for organizing the code. However, the use of one or another paradigm is up to the programmer, and both have pros and cons. Python supports both paradigms (some other languages only support one)
"""

class SimpleClass:
    greeting ="Hello"
    def funct1(self):
        print("This is a simple class")


class Computer:
    name  = ""
    kind  = "Laptop"
    color = ""
    cost  = 500
    def description(self):
        desc_str = "%s is a %s %s worth $%.2f."%(self.name,self.color,self.kind,self.cost)
        return desc_str

simple_object = SimpleClass()
print(simple_object.greeting)

comp = Computer()
print(comp.kind)

print(comp.name)
comp.name="Lenovo"
print(comp.name)

comp.color="blue"

comp.description()

class Computer:
    def __init__(self, name="n/a",kind  = "Laptop", color = "n/a", cost  = 500):
        self.name  = name
        self.kind=kind
        self.color = color
        self.cost  = cost
        desc_str = "%s is a %s %s worth $%.2f."%(self.name,self.color,self.kind,self.cost)
        print(desc_str)

comp = Computer()

"""#Retrieving files from internet and loading files into Colab

##Retrieving a file into a variable (or object)
"""

import urllib.request
from IPython.display import Image, display

urllib.request.urlretrieve(
  'https://upload.wikimedia.org/wikipedia/en/1/11/Disaster_Girl.jpg','Disaster_Girl.png')
display(Image("Disaster_Girl.png", width=50, height=50))
display(Image("Disaster_Girl.png"))

"""## Retrieving a file into the local filesystem"""

#!wget https://raw.githubusercontent.com/amgonzalezvargas/course_signals_data_health/main/ecg_signal.csv

"""## Uploading file from local drive"""

#from google.colab import files
#uploaded = files.upload()

"""# Loading files from Google Drive"""

# Commented out IPython magic to ensure Python compatibility.
#from google.colab import drive

#drive.mount('/content/gdrive/', force_remount=True)
# %cd gdrive/MyDrive

"""## Cloning a Github repository"""

#!git clone https://github.com/amgonzalezvargas/course_signals_data_health.git

#!ls

