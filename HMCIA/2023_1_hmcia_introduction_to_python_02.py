# -*- coding: utf-8 -*-
"""2023_1_HMCIA_Introduction_to_Python_02.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q-NsP923e-HqAwI-HgswUf2aA4zHOR43

# Modules in Python

# sys module

This module provides variables and methods that are directly related to the Python interpreter.

#os module 
 
This module provides access to variables and functions that interact directly with the operating system.
"""

import sys

print(sys.version)
print(sys.platform)
print(sys.getdefaultencoding())

import os 
print(os.getcwd())
#os.mkdir('/NuevaCarpeta')

with open('newfile.txt', 'w') as f:
    f.write('A new text file!')
f.close()

src='newfile.txt'
dst='newfile2.txt'
#os.copy(src,dst)

import shutil

shutil.copyfile(src,dst)

old_name='newfile2.txt'
new_name='newfile3.txt'
os.rename(old_name,new_name)

#!git clone https://github.com/amgonzalezvargas/miscellaneous.git

"""#Math
These functions allow us to perform various arithmetic operations such as calculating the upper or lower values of a number, factor calculations or the greatest common factor.
"""

import math
# fabs(x) : this function returns the absolute value of value x. 
print(math.fabs(-1234)) # Devolverá 1234 
# gcd(x,y) : this function returns the greatest common divisor of two values x and y. 
print(math.gcd(34, 82)) # Devolverá 2 
# floor(x) : this function returns the largest integer value that is less than or equal to x. 
print(math.floor(245.89)) # Devolverá 245 
# ceil(x) : this function returns the smallest integer value that is greater than or equal to x. 
print(math.ceil(245.89)) # Devolverá 246 
# factorial(x) : this function calculates the factorial of the number x. 
print(math.factorial(5)) # Devolverá 120 
# trunc(x) : this function returns the integer part of the number x. 
print(math.trunc(5.7836)) # Devolverá 5 
# sin(x) : returns the value of the sine of angle x in radians. 
print(math.sin(math.pi/4)) # Devolverá 0.7071067811865476 
# cos(x) : returns the value of the cosine of angle x in radians. 
print(math.cos(math.pi)) # Devolverá ‐1.0 
# tan(x) : this function returns the value of the tangent of angle x in radians. 
print(math.tan(math.pi/2)) # Devolverá 1.633123935319537e+16 
# asin(x) : this function calculates the value of the angle so that its sine is x. 
print(math.asin(1)) # Devolverá 1.5707963267948966 
# acos(x) : this function calculates the value of the angle so that its cosine is x. 
print(math.acos(1)) # Devolverá 0.0 
# atan(x) : this function calculates the value of the angle so that its tangent is x. 
print(math.atan(1)) # Devolverá 0.7853981633974483 
'''
hypot(x, y) : this function calculates the length of the hypotenuse of a right
triangle from the values of the two catheti x,y. 
'''
print(math.hypot(10, 7)) # Devolverá 12.206555615733702 
''' log(x, [base]) : this function allows you to calculate the logarithm of x. 
You can specify the base of the algorithm, although this argument 
is not required and by default it is calculated on base e. '''
print(math.log(148.41315910257657)) # Devolverá 5.0 
print(math.log(148.41315910257657, 2)) # Devolverá 7.213475204444817 
print(math.log(148.41315910257657, 10)) # Devolverá 2.171472409516258 
''' log2(x) : this function allows you to calculate the logarithm of x with base 2. 
It returns a more precise result than using the log(x, 2) function.''' 
print(math.log2(148.41315910257657)) # Devolverá 7.2134752044448165 
''' log10(x) : this function allows you to calculate the logarithm of x with 
base 10. It returns a more precise result than using the log(x, 10) function.''' 
print(math.log10(148.41315910257657)) # Devolverá 2.171472409516259 
# pow(x, y) : this function allows you to calculate the value of x raised to the power y. 
print(math.pow(2, 3)) # Devolverá 8 
# sqrt(x) : this function calculates the square root of the x value. 
print(math.sqrt(256)) # Devolverá 16 
# pi : contains the value of the number pi. 
print(math.pi) # Devolverá 3.141592653589793 
# e : contains the value of the number e. 
print(math.e) # Devolverá 2.718281828459045

"""#Módulo random 

This module provides us with methods to get random values.
"""

import random

#randint(x, y): devuelve un número aleatorio entre x e y. 
print(random.randint(1,10)) # Devolverá, por ejemplo, 7 
#choice(secuencia): devuelve un dato aleatorio de los datos de la secuencia. 
print(random.choice(['Hola', 3, [2, 3], True])) # Devolverá, por ejemplo, True 
#shuffle(secuencia): permuta los elementos de una secuencia de forma aleatoria. 
lista = ['Hola', 3, [2, 3], True] 
print(random.shuffle(lista)) 
lista # Mostrará, por ejemplo, [3, 'Hola', True, [2, 3]] 
#sample(secuencia, n): devuelve n elementos aleatorios de una secuencia. 
lista = ['Hola', 3, [2, 3], True] 
print(random.sample(lista, 2)) # Devolverá, por ejemplo, [[2, 3], True]

"""#Pandas
Is another module. It's main goal is data manipulation and analysis in Python. It includes new data structures and operations to manipulate data tables.
"""

import pandas as pd

"""##Series
Series are one-dimensional data structures, like lists or arrays in numpy. What differentiates the series is that the index of each element can be a label that we assign, similar to what is done in dictionaries. To create a series we use the Series() method where we will add the values and, if we want, the custom indices.
"""

import numpy as np
my_series=pd.Series([1,2,3,4,5], index=['a', 'b', 'c', 'd', 'e'])
print(my_series)

series1=pd.Series(np.array([1, 2, 3, 4, 5]), index=['a', 'b', 'c', 'd', 'e'])
print(series1)

a_dictionary={'a':7,'b':8,'c':9}
series2=pd.Series(a_dictionary)
print(series2)

"""we can access series by index, range or position"""

print(series1['a'])
print(series1[3])
print(series1[:2])

print(series1.index)
print(series1.values)

"""Series are based on numpy arrays. For this reason, we can easily apply vectorized operations, just like we did with arrays in numpy. However, it is important that both strings have the same indices, otherwise they may return unexpected results."""

result=series1+series2
print(result)

print(series1*5)
print(np.sqrt(series1))

"""#Dataframe 
Dataframes are the most used structure in pandas. These dataframes are a two-dimensional structure of labeled data, that is, they represent a table where each position of said table has a label in the row and another label in the column. There are many ways to build dataframes. They all use pandas's DataFrame() function. 
For example, we can build a dataframe from a dictionary that stores two strings:
"""

a_dict={'col1': pd.Series([1,2,3], index=['a','b','c']),
       'col2': pd.Series([5,6,8], index=['a','b','d'])}
df_small=pd.DataFrame(a_dict)
df_small

"""Another possible way to create a dataframe is through a list of dictionaries:"""

mylist=[{'a':1,'b':2,'c':5},{'b':4,'c':5}]
df_small2=pd.DataFrame(mylist)
df_small2

"""You can create a dataframe from a csv file. In some cases, these csv files include headers. In some other, they don't, so you have to create them. By default, the read_csv function assumes the file has headers"""

import pandas as pd
import requests


url1 = "https://archive.ics.uci.edu/ml/machine-learning-databases/heart-disease/processed.cleveland.data"
url2 = "https://archive.ics.uci.edu/ml/machine-learning-databases/heart-disease/heart-disease.names"
df = pd.read_csv(url1, header=None)
df.columns=['age','sex','chest_pain_type',
            'rest_blood_pressure','serum_cholesterol',
            'fasting_blood_sugar','rest_ecg','max_HR_achieved',
            'exercise_induced_angina','ST_depression','ST_slope','vessels_fluoroscopy','thal','heart_disease']

df_info = requests.get(url2).text

import pandas as pd
url3="https://gist.githubusercontent.com/LichAmnesia/3fb2e05cf654600882cf972c74f1e4ea/raw/293ca13a3d1a73fad54e5c6601c5843324d3694b/pandas_to_csv_2.csv"
mydf=pd.read_csv(url3)
display(mydf)

"""The dataset we downloaded is hosted at the UCI repository. In order to now more about it, we have also fetched the text file that describes in detail what information we can find in this dataset"""

print(df_info)

"""We can select columns from the dataframe by their column header"""

df.rest_blood_pressure

"""And we can also select rows by their index"""

print(df.loc[302])
print(df_small.loc['a'])
print(df_small.iloc[1])

"""We can add new columns, containing constant values or containing Series (if they have a different number of elements these will be considered NaN)

"""

df['new_col']=5
df['new_col2']=pd.Series([*range(300)])
df

"""We can also erase columns using their header (label)




"""

del df['new_col']
df

"""And we can apply different functions to a subgroup of columns. If these are boolean functions, we can use them to filter the elements of the dataframe"""

filtro=np.greater_equal(df.ST_depression,df.ST_slope)
df[filtro]

filtro=np.less_equal(df.rest_blood_pressure,110)
df[filtro]

"""We can also transpose the columns and rows of a dataframe, maybe for easeness of visualization"""

df.T

"""If we want to sort the elements of the dataframe in a different order we can use sort_values or sort_index. In both cases, pandas assumes an ascending order by default, so we have to tell it if we don't want it that way"""

df.sort_index(ascending=False)

df_small.sort_index(ascending=False)

"""the function "groupby" lets us group the elements of the dataframe based on the values of a given column, or group of columns"""

df.groupby(by='heart_disease')['heart_disease'].count()

df.groupby(by=['heart_disease','sex'])['sex'].count().reset_index(name='counts')

"""We can also apply functions (anonymous or otherwise) to all the elements of the dataframe, but we have to be careful to check if the data types are compatible with a given function"""

df.select_dtypes(include=['float64','int64']).apply(np.sqrt)

df.select_dtypes(include=['float64','int64']).apply(lambda x:x*3)

"""We can display some dataframe's statistics my using describe()"""

df.describe()

"""Or we can directly ask for some statistic value..."""

df.mean()

"""If we want to save the dataframe to a file, we can use the to_csv function"""

df2=df.select_dtypes(include=['float64','int64']).apply(lambda x:x%2)
df2.to_csv('df2.csv')

"""#Introduction to data visualization

We can also import datasets directly in excel format
"""

#!wget https://github.com/amgonzalezvargas/course_signals_data_health/raw/main/datahmcia.xlsx
df_hmcia= pd.read_excel('datahmcia.xlsx', sheet_name='data')

df_hmcia

"""Let's check the answer times for every answer and question"""

df_hmcia.iloc[1:3,1:3]

"""We can change these times so they represent time in seconds"""

for x in range(0,len(df_hmcia)): 
  for y in range(21,41):
    t_q=int(df_hmcia.iloc[x,y].second + df_hmcia.iloc[x,y].minute*60 + df_hmcia.iloc[x,y].hour*3600)
    df_hmcia.iloc[x,y]=t_q
display(df_hmcia.iloc[:,21:41])

"""## Matplotlib

This package let us create different kinds of plots
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib
import matplotlib.pyplot as plt
# %matplotlib inline

"""We can draw line plots"""

y=df_hmcia.iloc[1,21:41]
plt.plot(y)
y2=df_hmcia.iloc[2,21:41]
plt.plot(y2)

"""We can also change the markers and colors"""

plt.plot(y,'or')
plt.plot(y2,'xb')

x=np.array([*range(1,21)])
plt.plot(x,y,'--',linewidth=3)

"""Some plots need to be resized, and it's useful to include a legend"""

plt.rcParams['figure.figsize'] = [20, 5]
plt.xticks(np.arange(min(x), max(x)+1, 1.0))
plt.plot(x,y,'--',linewidth=3,label='s1')
plt.legend(bbox_to_anchor =(1.1,1.1))

"""Histogram lets us see the frequency of certain values"""

plt.hist(df_hmcia.E10)
matplotlib.rcParams.update(matplotlib.rcParamsDefault)
plt.xticks(np.arange(min(df_hmcia.E10), max(df_hmcia.E10)+1, 1.0))

plt.hist(df_hmcia.TQ10)

"""Some times, we want to take into account several columns at the same time"""

question_times=np.array(df_hmcia.iloc[:,21:41])
question_times=question_times.flatten()
plt.hist(question_times, range=(0,30),color='red')

"""Bar charts are useful to compare several subjects with regard to one variable"""

nota=5*(np.sum(df_hmcia.iloc[:,1:21],axis=1)/20)
labels=df_hmcia.Estudiante
plt.xticks(range(len(nota)), labels)
plt.yticks([0,1,2,3,4,5])
plt.xlabel('Estudiante')
plt.ylabel('Nota del quiz')
plt.title('Notas de los estudiantes en el quiz')
plt.bar(range(len(nota)), nota) 
plt.rcParams['figure.figsize'] = [15, 5]
plt.show()

autoconfianza=5*np.mean(df_hmcia.iloc[:,41:65],axis=1)/2
labels=df_hmcia.Estudiante
plt.xticks(range(len(autoconfianza)), labels)
plt.yticks([0,1,2,3,4,5])
plt.xlabel('Estudiante')
plt.ylabel('Autoconfianza')
plt.title('Autoconfianza de los estudiantes en los temas de Python')
plt.bar(range(len(autoconfianza)), autoconfianza, color='red') 
plt.rcParams['figure.figsize'] = [15, 5]
plt.show()

"""And we can also compare several variables """

#plt.bar(x_axis -0.2, female, width=0.4, label = 'Female')
#plt.bar(x_axis +0.2, male, width=0.4, label = 'Male')

width =0.3
plt.bar(np.arange(len(nota)), nota, width=width, label='nota') 
plt.bar(np.arange(len(autoconfianza))+width, autoconfianza, color='red', width=width, label='autoconfianza') 
labels=df_hmcia.Estudiante
plt.xticks(range(len(autoconfianza)), labels)
plt.legend()
plt.show()

"""You can also change the color of the plot"""

from matplotlib import style

x =[1,2,3,4,5,6]
y =[7,5,6,7,8,9]

x2 =[1,2,3,4,5,6]
y2 =[3,6,5,7,8,6]


style.use('dark_background')
plt.plot(x,y,label ='Line One')
plt.plot(x2,y2,label ='Line Two')
plt.xlabel('X axis')
plt.ylabel('Y axis')
plt.title('Simple Chart')

plt.legend()
plt.show()

"""And plot several subplots"""

#Siganl sampling rate 20000Hz

t = np.linspace(0,1.0,2001)

sig_5Hz = np.sin(2*np.pi*5*t)
sig_250Hz = np.sin(2*np.pi*250*t)
sig_5Hz_250Hz = sig_5Hz + sig_250Hz

style.use('dark_background')
f,plt_arr = plt.subplots(3, sharex=True)
f.suptitle('Signal Generation')

plt_arr[0].plot(sig_5Hz,color ='yellow')
plt_arr[0].set_title('5Hz signal', color ='yellow')

plt_arr[1].plot(sig_250Hz,color ='yellow')
plt_arr[1].set_title('250Hz signal', color ='yellow')

plt_arr[2].plot(sig_5Hz_250Hz,color ='cyan')
plt_arr[2].set_title('Combined 5Hz and 250Hz signal', color ='cyan')

plt.show()

#Siganl sampling rate 20000Hz

t = np.linspace(0,1.0,2001)

sig_5Hz = np.sin(2*np.pi*5*t)
sig_250Hz = np.sin(2*np.pi*250*t)
sig_5Hz_250Hz = sig_5Hz + sig_250Hz

style.use('ggplot')
f,plt_arr = plt.subplots(2,2, figsize=(10,5))
f.suptitle('Signal Generation')

plt_arr[0,0].plot(sig_5Hz,color ='red')
plt_arr[0,0].set_title('5Hz signal', color ='red')

plt_arr[0,1].plot(sig_5Hz,color ='red')
plt_arr[0,1].set_title('5Hz signal', color ='red')

plt_arr[1,0].plot(sig_250Hz,color ='blue')
plt_arr[1,0].set_title('250Hz signal', color ='blue')

plt_arr[1,1].plot(sig_5Hz_250Hz,color ='blue')
plt_arr[1,1].set_title('Combined 5Hz and 250Hz signal', color ='blue')

f.tight_layout()
plt.show()

"""#Numpy 
Numpy is a module that we can install in Python and it is oriented towards scientific libraries. This module provides new data structures, such as arrays and multidimensional arrays, and includes very powerful methods for working with them. 

This library is the basis for many of the scientific and data analysis libraries that exist in Python. 

#Arrays in numpy 

it's the most basic structure that exists within numpy. This data structure is a sequence of values, which are assigned a position. 
"""

import numpy as np
myarray=np.array([*range(1,6)])
print(myarray[2])
myarray=np.array([1, 2.0, 'Hola', True])
mymatrix=np.array([[1,2,3],[4,5,6]])
mymatrix=np.array([[1,2,3],[4,5]])

"""Arrays are very similar to Python lists, but arrays are faster and there are many calculations we can do on all the values ​​in an array faster than with Python lists."""

import sys
mylist=[*range(1000)]
myarray=np.array([*range(1000)])
listsize=0 

for k in mylist: listsize+=sys.getsizeof(k)
print(listsize)

arraysize=0 
for k in myarray: arraysize+=k.itemsize
print(arraysize)

import time
list1=[*range(1000000)]
list2=[*range(1000000)]
array1=np.array([*range(1000000)])
array2=np.array([*range(1000000)])
comienzo=time.time()
resultado=[x-y for x,y in zip(list1,list2)]
final=time.time()
print('Tiempo: ', final-comienzo)

comienzo=time.time()
resultado=array1 - array2
final=time.time()
print('Tiempo: ', final-comienzo)

"""#Array operations (element-wise)"""

array1=np.array([ 2, 3, 5])
array2=np.array([ 2, 4, 10])

print(np.subtract(array1,array2))
print(array1-array2)

print(np.add(array1,array2))
print(array1+array2)

print(np.multiply(array1,array2))
print(array1*array2)

print(np.divide(array1,array2))
print(array1/array2)

print(np.power(array1,array2))
print(array1**array2)

print(np.power(array1,2))
print(array1**2)

print(np.sqrt(array1))

print(np.square(array1))


print(np.gcd(array1,array2))

print(np.lcm(array1,array2))

"""#Array comparisons (element-wise)"""

print(np.greater(array1,array2))
print(np.greater_equal(array1,array2))
print(np.equal(array1,array2))
print(np.less(array1,array2))
print(np.less_equal(array1,array2))
print(np.not_equal(array1,array2))

"""#Array logical operations (element-wise)"""

array1=np.array([True, False, True])
array2=np.array([False, False, True])
print(np.logical_and(array1,array2))
print(np.logical_or(array1,array2))
print(np.logical_xor(array1,array2))
print(np.logical_not(array1))

"""#Array statistics"""

array1=np.array([*range(101)])
print(np.amin(array1))
print(np.amax(array1))
print(np.percentile(array1,50))
print(np.median(array1))
print(np.mean(array1))
print(np.std(array1))
print(np.var(array1))

"""#Matrices

A rectangular grid of numbers arranged in rows and columns. Variables that represent matrices are typically written as capital letters (boldfaced as well if you want to be super formal).

\begin{align}
A = 
    \begin{bmatrix}
           1 & 2 & 3\\
           4 & 5 & 6\\
           7 & 8 & 9
    \end{bmatrix}
    \qquad
    B = \begin{bmatrix}
           1 & 2 & 3\\
           4 & 5 & 6
    \end{bmatrix}
 \end{align}


"""

import numpy as np

A = np.array([[1, 2, 3], 
              [4, 5, 6],
              [7, 8, 9]])
B = np.array([[1, 2, 3], 
              [4, 5, 6]])

print(A.shape,B.shape)

"""#Matrix operations

##Matrix addition

If A and B are matrices of the same size, then they can be added.

\begin{align}
A = 
    \begin{bmatrix}
           1 & 2 & 3\\
           4 & 5 & 6\\
           7 & 8 & 9
    \end{bmatrix}
    \qquad
    B = \begin{bmatrix}
           1 & 2 & 3\\
           4 & 5 & 6
    \end{bmatrix}
        \qquad
    C = \begin{bmatrix}
           4 & 7 & 8\\
           3 & 7 & 9 \\
           3 & 4 & 8 \\
    \end{bmatrix}
 \end{align}

\begin{align}
A+B \text{ is not possible}\\
A+C \text{ is possible}
\end{align}

The sum $A+B$ of two $m$-by-$n$ matrices $A$ and $B$ is calculated entrywise:
$(A + B)_{i,j} = A_{i,j} + B_{i,j}$, where $1 ≤ i ≤ m$ and $1 ≤ j ≤ n$.
"""

A = np.array([[1, 2, 3], 
              [4, 5, 6],
              [7, 8, 9]])
C = np.array([[4, 7, 8], 
              [3, 7, 9],
              [3, 4, 8]])
B = np.array([[1, 2, 3], 
              [4, 5, 6]])
print(A+C)
#print(A+B)

"""##Scalar multiplication

The product $cA$ of a scalar c and a matrix A is computed by multiplying every entry of A by c:
$(cA)_{i,j} = c · A_{i,j}$.
This is not the same as "scalar product".
"""

print(A)
print(2*A)

"""##Transposition
The transpose of an $m$-by-$n$ matrix $A$ is the $n$-by-$m$ matrix $A^T$ formed by turning rows into columns and vice versa:
$A^T_{i,j} = A_{j,i}$.
"""

print(B)
print(B.transpose())

"""##Matrix multiplication
Multiplication of two matrices is defined if and only if the number of columns of the left matrix is the same as the number of rows of the right matrix. If A is an m-by-n matrix and B is an n-by-p matrix, then their matrix product AB is the m-by-p matrix whose entries are given by dot product of the corresponding row of A and the corresponding column of B.

\begin{align}
{\displaystyle [\mathbf {AB} ]_{i,j}=a_{i,1}b_{1,j}+a_{i,2}b_{2,j}+\cdots +a_{i,n}b_{n,j}=\sum _{r=1}^{n}a_{i,r}b_{r,j},}
\end{align}
"""

import urllib.request
from IPython.display import Image, display
urllib.request.urlretrieve(
  'https://upload.wikimedia.org/wikipedia/commons/e/e5/MatrixMultiplication.png','MatrixMultiplication.png')
display(Image("MatrixMultiplication.png", width=400, height=250))

"""Matrix multiplication satisfies the rules (AB)C = A(BC) (associativity), and (A + B)C = AC + BC as well as C(A + B) = CA + CB (left and right distributivity), whenever the size of the matrices is such that the various products are defined. The product AB may be defined without BA being defined, namely if A and B are m-by-n and n-by-k matrices, respectively, and m ≠ k. Even if both products are defined, they generally need not be equal, that is: AB ≠ BA,
In other words, matrix multiplication is not commutative,
"""

print(A.dot(C))
print(C.dot(A))

"""#Summary Statistics

Let's start by importing some data about different mammals' sleep habits. This dataset has been extracted from https://ggplot2.tidyverse.org/reference/msleep.html#details, which, in turn, was expanded from V. M. Savage and G. B. West. A quantitative, theoretical framework for understanding mammalian sleep. Proceedings of the National Academy of Sciences, 104 (3):1051-1056, 2007.

Format: A data frame with 83 rows and 11 variables:
* name: common name
* genus: generic scientific name
* vore: carnivore, omnivore or herbivore?
* order:  taxonomic rank between family and class.
* conservation: the conservation status of the animal
* sleep_total: total amount of sleep, in hours
* sleep_rem: rem sleep, in hours
* sleep_cycle: length of sleep cycle, in hours
* awake: amount of time spent awake, in hours
* brainwt: brain weight in kilograms
* bodywt: body weight in kilograms
"""

import pandas as pd
import numpy as np
import statistics as st

url1 = "https://raw.githubusercontent.com/profandresg/pyzero/main/mammalsleep.csv"
msleep = pd.read_csv(url1)
display(msleep)

"""**Histograms:**

A histogram takes many data points and separates them into bins, or ranges of values. The heights of the bars represent the number of data points that fall into that bin. Histograms are a good way to visually summarize the data.
"""

import matplotlib.pyplot as plt
plt.hist(msleep['sleep_total'])

"""**Density plot:** 

A density plot is a smoothed, continuous version of a histogram estimated from the data. The most common form of estimation is known as kernel density estimation. In this method, a continuous curve (the kernel) is drawn at every individual data point and all of these curves are then added together to make a single smooth density estimation. The kernel most often used is a Gaussian (which produces a Gaussian bell curve at each data point).
"""

# Density Plot and Histogram of all arrival delays
import seaborn as sns
sns.displot(data=msleep['sleep_total'],  kde=True)

"""# Scipy

SciPy provides algorithms for optimization, integration, interpolation, eigenvalue problems, algebraic equations, differential equations, statistics and many other classes of problems.
Extends NumPy providing additional tools for array computing and provides specialized data structures, such as sparse matrices and k-dimensional trees.

## Importing and Exporting Matlab data
"""

from scipy import io
import numpy as np

arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9,])

# Export:
io.savemat('arr.mat', {"vec": arr})

# Import:
mydata = io.loadmat('arr.mat')

print(mydata)
print(mydata['vec'][0])
print(sum(mydata['vec'][0]))
print(np.mean(mydata['vec'][0]))

"""# Interpolating data"""

from scipy.interpolate import interp1d
import numpy as np

xs = np.arange(10)
print(xs)
ys = 2*xs + 1
print(ys)

plt.figure()
plt.plot(xs,ys,'o')
interp_func = interp1d(xs, ys)

newxs=np.arange(2.1, 3, 0.1)
newys = interp_func(newxs)

plt.plot(newxs,newys,'o')
print(newys)

"""##Fast Fourier Transform

"""

from scipy.fft import fft, fftfreq
import numpy as np
import matplotlib.pyplot as plt
# Number of sample points
N = 2000
# sample spacing
T = 1.0 / 1000

x = np.linspace(0.0, N*T, N, endpoint=False)
y1 = np.sin(4.0 * 2.0*np.pi*x)  #4Hz
y2 = 0.5*np.sin(10.0 * 2.0*np.pi*x) #10Hz
y3 = 0.5*np.sin(60.0 * 2.0*np.pi*x) #60Hz

plt.rcParams['figure.figsize'] = [20, 5]
plt.figure()
plt.plot(x,y1)
plt.figure()
plt.plot(x,y2)
plt.figure()
plt.plot(x,y3)

y=y1+y2+y3
plt.figure()
plt.plot(x,y)

yf = fft(y)
xf = fftfreq(N, T)[:N//2]
import matplotlib.pyplot as plt
plt.figure()
plt.plot(xf, 2.0/N * np.abs(yf[0:N//2]))
plt.grid()
plt.xlim([0,100])
plt.show()

"""## Filtering"""

from scipy import signal
b, a = signal.butter(N=3, btype='bandpass', Wn=[1,40], fs=1.0/T)
print(f'numerator is {b} and denominator is {a}')
zi = signal.lfilter_zi(b, a)
yfilt = signal.filtfilt(b, a, y)
plt.plot(x,yfilt)

b=0.1
a=0.3
print(a==(3*b))

yfilt_f = fft(yfilt)
plt.figure()
plt.plot(xf, 2.0/N * np.abs(yfilt_f[0:N//2]))
plt.grid()
plt.xlim([0,100])
plt.show()

"""#Convolution"""

#006 - 1_Convolution_v1
#!wget https://raw.githubusercontent.com/amgonzalezvargas/course_signals_data_health/main/mysignals.py
from matplotlib import pyplot as plt
from matplotlib import style
from scipy import signal
import mysignals as sigs


output_signal = signal.convolve(sigs.InputSignal_1kHz_15kHz,sigs.Impulse_response, mode='same')

style.use('ggplot')

f,plt_arr = plt.subplots(2,sharex=True)
f.suptitle("Convolution")
plt_arr[0].plot(sigs.InputSignal_1kHz_15kHz, color ='cyan', label='Input')
plt_arr[0].set_title("Input Signal")
plt_arr[1].plot(sigs.Impulse_response, color ='red')
#plt_arr[1].plot(anothersig, color ='pink')
plt_arr[1].set_title("Impulse Response")
plt_arr[0].plot(output_signal, '--', color ='magenta', label='Output')


plt_arr[0].legend(loc="upper left")
plt.show()

"""# Running Sum"""

# 010 - 5_Running_Sum

from matplotlib import pyplot as plt
from matplotlib import style
import mysignals as sigs
import numpy as np


output_signal = 0.1*np.cumsum(sigs.InputSignal_1kHz_15kHz)

style.use('dark_background')

fig, ax = plt.subplots()
ax.plot(sigs.InputSignal_1kHz_15kHz, color='blue', label='Input Signal')
ax.plot(output_signal, '--r', label='Output Signal')
#ax.axis('equal')
leg = ax.legend();


plt.show()

"""# First Difference"""

#012 - 6_First_Difference

from matplotlib import pyplot as plt
from matplotlib import style
import mysignals as sigs
import numpy as np


output_signal = np.diff(sigs.InputSignal_1kHz_15kHz)

style.use('ggplot')
#style.use('dark_background')

f,plt_arr = plt.subplots(2,sharex=True)
f.suptitle("First Difference")

plt_arr[0].plot(sigs.InputSignal_1kHz_15kHz,color='red')
plt_arr[0].set_title("Input Signal")

plt_arr[1].plot(output_signal,color ='magenta')
plt_arr[1].set_title("Output Signal")

plt.show()

"""#FFT and IFFT"""

#018 - fft

import mysignals as sigs
from matplotlib import pyplot as plt
from scipy.fftpack import fft,ifft
import numpy as np
from matplotlib import style

freq_domain_signal = fft(sigs.ecg_signal)
time_domain_signal = ifft(freq_domain_signal)
magnitude = np.abs(freq_domain_signal)

style.use('dark_background')

f,plt_arr= plt.subplots(3,sharex=True)
f.suptitle("Fast Fourier Transform (FFT)")

plt_arr[0].plot(sigs.ecg_signal,color='red')
plt_arr[0].set_title("Time Domain (Input Signal)", color ='red')

#plt_arr[1].plot(freq_domain_signal,color='cyan')
#plt_arr[1].set_title("Frequency Domain (FFT)", color ='cyan')
#plt_arr[2].plot(magnitude,color='cyan')
#plt_arr[2].set_title("Magnitude", color ='cyan')

plt_arr[1].plot(magnitude,color='cyan')
plt_arr[1].set_title("Magnitude Frequency Domain (FFT)", color ='cyan')


plt_arr[2].plot(time_domain_signal,color='green')
plt_arr[2].set_title("Time Domain (IFFT)", color ='green')

plt.show()

"""#Importing data from Physionet Database

## Install and import the WFDB package
"""

#!pip install wfdb
import wfdb

style.use('seaborn')


# load a record using the 'rdrecord' function
record = wfdb.rdrecord('a103l', pn_dir='challenge-2015/training/')

# plot the record to screen
wfdb.plot_wfdb(record=record, title='Example signals')

display(record.__dict__)

"""## Read channels and sections of the WFDB record using 'rdsamp' """

signals, fields = wfdb.rdsamp('s0010_re', channels=[14, 0, 5, 10], sampfrom=100, sampto=15000, pn_dir='ptbdb/patient001/')
display(signals)
display(fields)

"""# Read a WFDB header file only (without the signals)"""

record = wfdb.rdheader('drive02', pn_dir='drivedb')
display(record.__dict__)

"""## DRead a WFDB record and annotation.

"""

#record = wfdb.rdrecord('100', sampto = 15000)
record = wfdb.rdrecord('100', pn_dir='mitdb', channels=[0],  sampto = 3000)

#annotation = wfdb.rdann('sample-data/100', 'atr', sampto = 15000)
annotation = wfdb.rdann('100', 'atr', sampto=3000, pn_dir='mitdb')
annotation.fs = 360


wfdb.plot_wfdb(record=record, annotation=annotation,
               title='Record 100 from MIT-BIH Arrhythmia Database',
               time_units='seconds')

"""## List the PhysioNet Databases"""

dbs = wfdb.get_dbs()
display(dbs)

a=200*1/360
print(a)

print(60*1/a)

print(1/0.2)

